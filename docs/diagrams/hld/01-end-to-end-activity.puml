@startuml
title AccessGuard - End-to-end Flow (Enhanced Activity)

skinparam backgroundColor white
skinparam shadowing false
skinparam activity {
  BorderColor #333333
  FontColor #111111
  ArrowColor #333333
}
skinparam note {
  BorderColor #333333
  FontColor #111111
}

legend top
Conventions:
- tenantId enforced everywhere (core + audit)
- correlationId recommended for tracing across services
- attemptId stable per physical attempt to support safe retries
- Kafka delivery assumed at-least-once; consumers must be idempotent

Kafka event envelope (authoritative for audit):
- eventId: UUID
- eventType: accessguard.access_attempt_recorded
- schemaVersion: integer
- tenantId: string
- occurredAt: timestamp
- correlationId: string optional
Payload: attemptId, doorId, pass reference, decision, reasonCode
endlegend

|Tenant Admin|
start
:Create or update pass\nPass APIs;
note right
Identity: JWT
tenantId derived from JWT claim (e.g., tid)
correlationId recommended per request
end note

|accessguard-core|
:Persist pass\ncore DB;
note right
Data ownership:
- core is the only writer for pass data
- passCode is server-generated by default (random)
end note

|Tenant Admin|
:Pass ready for use;

|Access Device|
:Submit access attempt\nPOST /access-attempts\nattemptId, doorId, passCode;
note right
Identity: device credential (JWT or mTLS)
tenantId derived in core from device identity
Inputs:
- attemptId: stable idempotency key
- doorId required; zone derived from door
- passCode short code or QR content
- correlationId header optional, recommended
end note

|accessguard-core|
:Derive tenant context\nfrom device identity;
:Idempotency check\nunique tenantId + attemptId;

if (Duplicate attempt?) then (yes)
  :Return cached decision\nGRANTED or DENIED + reasonCode;
  note right
Determinism:
duplicate tenantId+attemptId returns identical decision and reasonCode
end note
  |Access Device|
  :Receive decision;
  stop
else (no)
  :Resolve device authorization\nwithin tenant;

  if (Device valid?) then (yes)
    :Lookup door by doorId\nwithin tenant;

    if (Door found?) then (yes)
      :Lookup pass by passCode\nwithin tenant;

      if (Pass found?) then (yes)
        :Check pass state;

        if (Pass revoked?) then (yes)
          :Decision DENIED\nreasonCode PASS_REVOKED;
        else (no)
          :Check validity window;

          if (Window valid?) then (yes)
            :Check authorization scope\nDoor or zone hierarchy;

            if (Authorized?) then (yes)
              :Decision GRANTED\nreasonCode OK;
            else (no)
              :Decision DENIED\nreasonCode OUT_OF_SCOPE;
            endif

          else (no)
            :Decision DENIED\nreasonCode PASS_EXPIRED_OR_NOT_YET_VALID;
          endif
        endif

      else (no)
        :Decision DENIED\nreasonCode PASS_NOT_FOUND;
      endif

    else (no)
      :Decision DENIED\nreasonCode DOOR_NOT_FOUND;
    endif

  else (no)
    :Decision DENIED\nreasonCode DEVICE_NOT_ALLOWED;
  endif

  note right
Reason codes (minimum set):
- OK
- DEVICE_NOT_ALLOWED
- DOOR_NOT_FOUND
- PASS_NOT_FOUND
- PASS_REVOKED
- PASS_EXPIRED_OR_NOT_YET_VALID
- OUT_OF_SCOPE

HTTP semantics for device API:
- prefer 200 with decision + reasonCode
- avoid 404 leakage for pass/door existence
end note

  :Persist access attempt + decision\ncore DB;
  note right
Core persistence supports:
- traceability (operational record)
- idempotency via tenantId+attemptId uniqueness
- deterministic responses under retries
end note

  :Publish event access_attempt_recorded;
  note right
Event payload guidance:
- include tenantId, attemptId, doorId
- include decision + reasonCode
- include correlationId for tracing
- schemaVersion increments on contract changes
Pass reference:
- prefer passId or hashed/aliased passCode
end note

  |Access Device|
  :Receive decision;
endif

|Kafka|
:Topic accessguard.events\nstores event;

|accessguard-audit|
:Consume event access_attempt_recorded;
:Consumer idempotency check\nprimary eventId\nfallback tenantId+attemptId;

if (Duplicate event?) then (yes)
  :Skip (no-op);
else (no)
  :Persist immutable audit record\naudit DB;
  note right
Audit persistence rules:
- append-only semantics
- audit is the only writer to audit DB
- tenant-scoped records
end note
endif

:Audit query API available;

|Security Officer|
:Query audit\nfilters time, decision, door, pass, zone;
note right
Authorization:
- SECURITY role (read-only)
- tenantId from JWT claim
Observability:
- correlationId traces core logs, Kafka event, audit logs
end note
:Receive results paginated;
stop

@enduml
